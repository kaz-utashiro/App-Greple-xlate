=encoding utf-8

=head1 NAME

App::Greple::xlate - μονάδα υποστήριξης μετάφρασης για το greple

=head1 SYNOPSIS

    greple -Mxlate::deepl --xlate pattern target-file

    greple -Mxlate::gpt4 --xlate pattern target-file

    greple -Mxlate --xlate-engine gpt4 --xlate pattern target-file

=head1 VERSION

Version 0.9910

=head1 DESCRIPTION

B<Greple> B<xlate> η μονάδα εντοπίζει τα επιθυμητά μπλοκ κειμένου και τα αντικαθιστά με το μεταφρασμένο κείμενο. Προς το παρόν, οι DeepL (F<deepl.pm>) και ChatGPT 4.1 (F<gpt4.pm>) έχουν υλοποιηθεί ως μηχανές back-end.

Αν θέλετε να μεταφράσετε κανονικά μπλοκ κειμένου σε ένα έγγραφο γραμμένο σε στυλ pod της Perl, χρησιμοποιήστε την εντολή B<greple> με τις μονάδες C<xlate::deepl> και C<perl> ως εξής:

    greple -Mxlate::deepl -Mperl --pod --re '^([\w\pP].*\n)+' --all foo.pm

Σε αυτή την εντολή, η συμβολοσειρά μοτίβου C<^([\w\pP].*\n)+> σημαίνει διαδοχικές γραμμές που ξεκινούν με αλφαριθμητικό ή σημείο στίξης. Αυτή η εντολή εμφανίζει την περιοχή που θα μεταφραστεί με επισήμανση. Η επιλογή B<--all> χρησιμοποιείται για την παραγωγή ολόκληρου του κειμένου.

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/select-area.png">
</p>

Στη συνέχεια, προσθέστε την επιλογή C<--xlate> για να μεταφράσετε την επιλεγμένη περιοχή. Έπειτα, θα βρει τα επιθυμητά τμήματα και θα τα αντικαταστήσει με την έξοδο της εντολής B<deepl>.

Από προεπιλογή, το αρχικό και το μεταφρασμένο κείμενο εκτυπώνονται σε μορφή "conflict marker" συμβατή με το L<git(1)>. Χρησιμοποιώντας τη μορφή C<ifdef>, μπορείτε να πάρετε το επιθυμητό μέρος εύκολα με την εντολή L<unifdef(1)>. Η μορφή εξόδου μπορεί να καθοριστεί με την επιλογή B<--xlate-format>.

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/format-conflict.png">
</p>

Αν θέλετε να μεταφράσετε ολόκληρο το κείμενο, χρησιμοποιήστε την επιλογή B<--match-all>. Αυτή είναι μια συντόμευση για να καθορίσετε το μοτίβο C<(?s).+> που ταιριάζει με ολόκληρο το κείμενο.

Τα δεδομένα σε μορφή conflict marker μπορούν να προβληθούν σε στυλ δίπλα-δίπλα με την εντολή C<sdif> και την επιλογή C<-V>. Επειδή δεν έχει νόημα η σύγκριση ανά συμβολοσειρά, συνιστάται η επιλογή C<--no-cdif>. Αν δεν χρειάζεστε χρωματισμό του κειμένου, καθορίστε C<--no-textcolor> (ή C<--no-tc>).

    sdif -V --no-tc --no-cdif data_shishin.deepl-EN-US.cm

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/sdif-cm-view.png">
</p>

=head1 NORMALIZATION

Η επεξεργασία γίνεται σε καθορισμένες μονάδες, αλλά στην περίπτωση ακολουθίας πολλαπλών γραμμών μη κενών κειμένων, μετατρέπονται μαζί σε μία γραμμή. Αυτή η λειτουργία εκτελείται ως εξής:

=over 2

=item *

Αφαιρέστε τα κενά στην αρχή και το τέλος κάθε γραμμής.

=item *

Αν μια γραμμή τελειώνει με χαρακτήρα στίξης πλήρους πλάτους, ενώστε με την επόμενη γραμμή.

=item *

Αν μια γραμμή τελειώνει με χαρακτήρα πλήρους πλάτους και η επόμενη γραμμή αρχίζει με χαρακτήρα πλήρους πλάτους, ενώστε τις γραμμές.

=item *

Αν είτε το τέλος είτε η αρχή μιας γραμμής δεν είναι χαρακτήρας πλήρους πλάτους, ενώστε τις εισάγοντας ένα κενό διάστημα.

=back

Τα δεδομένα της προσωρινής μνήμης διαχειρίζονται με βάση το κανονικοποιημένο κείμενο, οπότε ακόμη και αν γίνουν τροποποιήσεις που δεν επηρεάζουν τα αποτελέσματα της κανονικοποίησης, τα αποθηκευμένα μεταφρασμένα δεδομένα θα παραμείνουν αποτελεσματικά.

Αυτή η διαδικασία κανονικοποίησης εκτελείται μόνο για το πρώτο (0ο) και τα ζυγά μοτίβα. Έτσι, αν καθοριστούν δύο μοτίβα ως εξής, το κείμενο που ταιριάζει με το πρώτο μοτίβο θα υποβληθεί σε επεξεργασία μετά την κανονικοποίηση, και δεν θα εκτελεστεί κανονικοποίηση στο κείμενο που ταιριάζει με το δεύτερο μοτίβο.

    greple -Mxlate -E normalized -E not-normalized

Επομένως, χρησιμοποιήστε το πρώτο μοτίβο για κείμενο που θα υποβληθεί σε επεξεργασία συνδυάζοντας πολλές γραμμές σε μία, και το δεύτερο μοτίβο για προδιαμορφωμένο κείμενο. Αν δεν υπάρχει κείμενο που να ταιριάζει με το πρώτο μοτίβο, χρησιμοποιήστε ένα μοτίβο που δεν ταιριάζει με τίποτα, όπως το C<(?!)>.

=head1 MASKING

Περιστασιακά, υπάρχουν μέρη του κειμένου που δεν θέλετε να μεταφραστούν. Για παράδειγμα, ετικέτες σε αρχεία markdown. Η DeepL προτείνει σε τέτοιες περιπτώσεις το μέρος του κειμένου που θα εξαιρεθεί να μετατρέπεται σε ετικέτες XML, να μεταφράζεται και στη συνέχεια να επαναφέρεται μετά την ολοκλήρωση της μετάφρασης. Για να υποστηριχθεί αυτό, είναι δυνατό να καθοριστούν τα μέρη που θα αποκλειστούν από τη μετάφραση.

    --xlate-setopt maskfile=MASKPATTERN

Αυτό θα ερμηνεύσει κάθε γραμμή του αρχείου `MASKPATTERN` ως κανονική έκφραση, θα μεταφράσει τις συμβολοσειρές που ταιριάζουν και θα τις επαναφέρει μετά την επεξεργασία. Οι γραμμές που ξεκινούν με C<#> αγνοούνται.

Σύνθετα μοτίβα μπορούν να γραφτούν σε πολλές γραμμές με διαφυγή της αλλαγής γραμμής με backslash.

Το πώς μετασχηματίζεται το κείμενο με τη μάσκα μπορεί να φανεί με την επιλογή B<--xlate-mask>.

Αυτή η διεπαφή είναι πειραματική και ενδέχεται να αλλάξει στο μέλλον.

=head1 OPTIONS

=over 7

=item B<--xlate>

=item B<--xlate-color>

=item B<--xlate-fold>

=item B<--xlate-fold-width>=I<n> (Default: 70)

Εκκινήστε τη διαδικασία μετάφρασης για κάθε ταιριαστή περιοχή.

Χωρίς αυτήν την επιλογή, το B<greple> λειτουργεί ως κανονική εντολή αναζήτησης. Έτσι μπορείτε να ελέγξετε ποιο μέρος του αρχείου θα αποτελέσει αντικείμενο μετάφρασης πριν ξεκινήσετε την πραγματική εργασία.

Το αποτέλεσμα της εντολής πηγαίνει στην τυπική έξοδο, οπότε ανακατευθύνετε σε αρχείο αν χρειάζεται ή σκεφτείτε να χρησιμοποιήσετε το L<App::Greple::update> module.

Η επιλογή B<--xlate> καλεί την επιλογή B<--xlate-color> με την επιλογή B<--color=never>.

Με την επιλογή B<--xlate-fold>, το μετατρεπόμενο κείμενο διπλώνεται στο καθορισμένο πλάτος. Το προεπιλεγμένο πλάτος είναι 70 και μπορεί να οριστεί με την επιλογή B<--xlate-fold-width>. Τέσσερις στήλες κρατούνται για λειτουργία run-in, οπότε κάθε γραμμή μπορεί να έχει το πολύ 74 χαρακτήρες.

=item B<--xlate-engine>=I<engine>

Καθορίζει τη μηχανή μετάφρασης που θα χρησιμοποιηθεί. Αν καθορίσετε απευθείας το module της μηχανής, όπως το C<-Mxlate::deepl>, δεν χρειάζεται να χρησιμοποιήσετε αυτήν την επιλογή.

Αυτή τη στιγμή, οι παρακάτω μηχανές είναι διαθέσιμες

=over 2

=item * B<deepl>: DeepL API

=item * B<gpt3>: gpt-3.5-turbo

=item * B<gpt4>: gpt-4.1

=item * B<gpt4o>: gpt-4o-mini

B<gpt-4o>'s interface είναι ασταθές και δεν μπορεί να εγγυηθεί ότι θα λειτουργεί σωστά αυτή τη στιγμή.

=back

=item B<--xlate-labor>

=item B<--xlabor>

Αντί να καλείτε τη μηχανή μετάφρασης, αναμένεται να εργαστείτε εσείς. Αφού προετοιμάσετε το κείμενο προς μετάφραση, αντιγράφεται στο πρόχειρο. Αναμένεται να το επικολλήσετε στη φόρμα, να αντιγράψετε το αποτέλεσμα στο πρόχειρο και να πατήσετε return.

=item B<--xlate-to> (Default: C<EN-US>)

Καθορίστε τη γλώσσα-στόχο. Μπορείτε να λάβετε τις διαθέσιμες γλώσσες με την εντολή C<deepl languages> όταν χρησιμοποιείτε τη μηχανή B<DeepL>.

=item B<--xlate-format>=I<format> (Default: C<conflict>)

Καθορίστε τη μορφή εξόδου για το αρχικό και το μεταφρασμένο κείμενο.

Οι παρακάτω μορφές εκτός από το C<xtxt> υποθέτουν ότι το μέρος που θα μεταφραστεί είναι μια συλλογή γραμμών. Στην πραγματικότητα, είναι δυνατό να μεταφραστεί μόνο ένα μέρος μιας γραμμής, αλλά αν ορίσετε μορφή εκτός από το C<xtxt> δεν θα παραχθούν ουσιαστικά αποτελέσματα.

=over 4

=item B<conflict>, B<cm>

Το αρχικό και το μετατρεπόμενο κείμενο εκτυπώνονται σε μορφή conflict marker L<git(1)>.

    <<<<<<< ORIGINAL
    original text
    =======
    translated Japanese text
    >>>>>>> JA

Μπορείτε να ανακτήσετε το αρχικό αρχείο με την επόμενη εντολή L<sed(1)>.

    sed -e '/^<<<<<<< /d' -e '/^=======$/,/^>>>>>>> /d'

=item B<colon>, I<:::::::>

Το αρχικό και το μεταφρασμένο κείμενο εξάγονται σε προσαρμοσμένο container markdown.

    ::::::: ORIGINAL
    original text
    :::::::
    ::::::: JA
    translated Japanese text
    :::::::

Το παραπάνω κείμενο θα μεταφραστεί ως εξής σε HTML.

    <div class="ORIGINAL">
    original text
    </div>
    <div class="JA">
    translated Japanese text
    </div>

Ο αριθμός των άνω κάτω τελειών είναι 7 από προεπιλογή. Αν καθορίσετε ακολουθία άνω κάτω τελειών όπως το C<:::::>, αυτή χρησιμοποιείται αντί για 7 άνω κάτω τελείες.

=item B<ifdef>

Το αρχικό και το μετατρεπόμενο κείμενο εκτυπώνονται σε μορφή L<cpp(1)> C<#ifdef>.

    #ifdef ORIGINAL
    original text
    #endif
    #ifdef JA
    translated Japanese text
    #endif

Μπορείτε να ανακτήσετε μόνο το ιαπωνικό κείμενο με την εντολή B<unifdef>:

    unifdef -UORIGINAL -DJA foo.ja.pm

=item B<space>

=item B<space+>

Το αρχικό και το μετατραπέν κείμενο εκτυπώνονται χωριστά με μία κενή γραμμή.

=item B<xtxt>

Για το C<space+>, εκτυπώνεται επίσης μια νέα γραμμή μετά το μετατραπέν κείμενο.

=back

=item B<--xlate-maxlen>=I<chars> (Default: 0)

Αν η μορφή είναι C<xtxt> (μεταφρασμένο κείμενο) ή άγνωστη, εκτυπώνεται μόνο το μεταφρασμένο κείμενο.

=item B<--xlate-maxline>=I<n> (Default: 0)

Καθορίστε το μέγιστο μήκος κειμένου που θα αποστέλλεται στο API κάθε φορά. Η προεπιλεγμένη τιμή έχει οριστεί όπως για τη δωρεάν υπηρεσία λογαριασμού DeepL: 128K για το API (B<--xlate>) και 5000 για τη διεπαφή πρόχειρου (B<--xlate-labor>). Μπορείτε να αλλάξετε αυτές τις τιμές αν χρησιμοποιείτε την υπηρεσία Pro.

Καθορίστε το μέγιστο αριθμό γραμμών κειμένου που θα αποστέλλονται στο API κάθε φορά.

=item B<-->[B<no->]B<xlate-progress> (Default: True)

Ορίστε αυτήν την τιμή σε 1 αν θέλετε να μεταφράζετε μία γραμμή κάθε φορά. Αυτή η επιλογή υπερισχύει της επιλογής C<--xlate-maxlen>.

=item B<--xlate-stripe>

Δείτε το αποτέλεσμα της μετάφρασης σε πραγματικό χρόνο στην έξοδο STDERR.

Χρησιμοποιήστε το L<App::Greple::stripe> για να εμφανίσετε το ταιριασμένο μέρος με εναλλασσόμενες ρίγες τύπου ζέβρας. Αυτό είναι χρήσιμο όταν τα ταιριασμένα μέρη συνδέονται διαδοχικά.

=item B<--xlate-mask>

Η παλέτα χρωμάτων αλλάζει ανάλογα με το χρώμα φόντου του τερματικού. Αν θέλετε να το ορίσετε ρητά, μπορείτε να χρησιμοποιήσετε το B<--xlate-stripe-light> ή το B<--xlate-stripe-dark>.

=item B<--match-all>

Εκτελέστε τη λειτουργία μάσκας και εμφανίστε το μετατραπέν κείμενο ως έχει χωρίς αποκατάσταση.

=item B<--lineify-cm>

=item B<--lineify-colon>

Στην περίπτωση των μορφών C<cm> και C<colon>, η έξοδος χωρίζεται και μορφοποιείται γραμμή προς γραμμή.

Επομένως, αν μόνο ένα μέρος μιας γραμμής μεταφραστεί, δεν μπορεί να ληφθεί το αναμενόμενο αποτέλεσμα.

=back

=head1 CACHE OPTIONS

Ορίστε ολόκληρο το κείμενο του αρχείου ως περιοχή στόχου.

Το B<xlate> μπορεί να αποθηκεύσει προσωρινά το μεταφρασμένο κείμενο για κάθε αρχείο και να το διαβάσει πριν την εκτέλεση ώστε να εξαλειφθεί το κόστος επικοινωνίας με τον διακομιστή. Με τη στρατηγική προσωρινής αποθήκευσης C<auto> ως προεπιλογή, διατηρεί τα δεδομένα cache μόνο όταν υπάρχει αρχείο cache για το αρχείο στόχο.

=over 7

=item --xlate-cache=I<strategy>

=over 4

=item C<auto> (Default)

Χρησιμοποιήστε το B<--xlate-cache=clear> για να ξεκινήσετε τη διαχείριση cache ή να καθαρίσετε όλα τα υπάρχοντα δεδομένα cache. Μόλις εκτελεστεί με αυτήν την επιλογή, θα δημιουργηθεί νέο αρχείο cache αν δεν υπάρχει και στη συνέχεια θα διατηρείται αυτόματα.

=item C<create>

Διατηρήστε το αρχείο cache αν υπάρχει.

=item C<always>, C<yes>, C<1>

Δημιουργήστε κενό αρχείο cache και τερματίστε.

=item C<clear>

Διατηρήστε το cache ούτως ή άλλως εφόσον ο στόχος είναι κανονικό αρχείο.

=item C<never>, C<no>, C<0>

Καθαρίστε πρώτα τα δεδομένα cache.

=item C<accumulate>

Μην χρησιμοποιείτε ποτέ αρχείο cache ακόμα κι αν υπάρχει.

=back

=item B<--xlate-update>

Από προεπιλογή, τα αχρησιμοποίητα δεδομένα αφαιρούνται από το αρχείο cache. Αν δεν θέλετε να τα αφαιρέσετε και να τα διατηρήσετε στο αρχείο, χρησιμοποιήστε το C<accumulate>.

=back

=head1 COMMAND LINE INTERFACE

Αυτή η επιλογή αναγκάζει την ενημέρωση του αρχείου cache ακόμα κι αν δεν είναι απαραίτητο.

Μπορείτε εύκολα να χρησιμοποιήσετε αυτήν τη μονάδα από τη γραμμή εντολών χρησιμοποιώντας την εντολή C<xlate> που περιλαμβάνεται στη διανομή. Δείτε τη σελίδα man C<xlate> για οδηγίες χρήσης.

Η εντολή C<xlate> λειτουργεί σε συνδυασμό με το περιβάλλον Docker, οπότε ακόμα κι αν δεν έχετε τίποτα εγκατεστημένο τοπικά, μπορείτε να το χρησιμοποιήσετε αρκεί να είναι διαθέσιμο το Docker. Χρησιμοποιήστε την επιλογή C<-D> ή C<-C>.

Επίσης, επειδή παρέχονται makefiles για διάφορα στυλ εγγράφων, είναι δυνατή η μετάφραση σε άλλες γλώσσες χωρίς ειδικό ορισμό. Χρησιμοποιήστε την επιλογή C<-M>.

Μπορείτε επίσης να συνδυάσετε τις επιλογές Docker και C<make> ώστε να μπορείτε να εκτελέσετε το C<make> σε περιβάλλον Docker.

Η εκτέλεση όπως C<xlate -C> θα εκκινήσει ένα shell με το τρέχον git repository προσαρτημένο.

=head1 EMACS

Φορτώστε το αρχείο F<xlate.el> που περιλαμβάνεται στο αποθετήριο για να χρησιμοποιήσετε την εντολή C<xlate> από τον επεξεργαστή Emacs.

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/emacs.png">
</p>

=head1 ENVIRONMENT

=over 7

=item DEEPL_AUTH_KEY

Η συνάρτηση C<xlate-region> μεταφράζει την επιλεγμένη περιοχή.

=item OPENAI_API_KEY

Η προεπιλεγμένη γλώσσα είναι C<EN-US> και μπορείτε να ορίσετε γλώσσα καλώντας τη με προθεματικό όρισμα.

=back

=head1 INSTALL

=head2 CPANMINUS

    $ cpanm App::Greple::xlate

=head2 TOOLS

Ορίστε το κλειδί ταυτοποίησης για την υπηρεσία DeepL.

Κλειδί ταυτοποίησης OpenAI.

Πρέπει να εγκαταστήσετε εργαλεία γραμμής εντολών για το DeepL και το ChatGPT.

=head1 SEE ALSO

L<https://github.com/DeepLcom/deepl-python>

L<https://github.com/tecolicom/App-gpty>

L<App::Greple::xlate::gpt4>

=over 2

=item * L<https://hub.docker.com/r/tecolicom/xlate>

L<App::Greple::xlate::deepl>

=item * L<https://github.com/DeepLcom/deepl-python>

L<App::Greple::xlate::gpt3>

=item * L<https://github.com/openai/openai-python>

Εικόνα κοντέινερ Docker.

=item * L<https://github.com/tecolicom/App-gpty>

Βιβλιοθήκη Python DeepL και εντολή CLI.

=item * L<App::Greple>

Βιβλιοθήκη Python OpenAI

=item * L<App::Greple::update>

Διεπαφή γραμμής εντολών OpenAI

=item * L<App::sdif>

Δείτε το εγχειρίδιο B<greple> για λεπτομέρειες σχετικά με το μοτίβο του κειμένου στόχου. Χρησιμοποιήστε τις επιλογές B<--inside>, B<--outside>, B<--include>, B<--exclude> για να περιορίσετε την περιοχή αντιστοίχισης.

=item * L<App::Greple::stripe>

Μπορείτε να χρησιμοποιήσετε το module C<-Mupdate> για να τροποποιήσετε αρχεία με το αποτέλεσμα της εντολής B<greple>.

=back

=head2 ARTICLES

=over 2

=item * L<https://qiita.com/kaz-utashiro/items/1c1a51a4591922e18250>

Χρησιμοποιήστε το B<sdif> για να εμφανίσετε τη μορφή δείκτη σύγκρουσης δίπλα-δίπλα με την επιλογή B<-V>.

=item * L<https://qiita.com/kaz-utashiro/items/a5e19736416ca183ecf6>

Το module Greple B<stripe> χρησιμοποιείται με την επιλογή B<--xlate-stripe>.

=item * L<https://qiita.com/kaz-utashiro/items/1b9e155d6ae0620ab4dd>

Module Greple για μετάφραση και αντικατάσταση μόνο των απαραίτητων τμημάτων με το DeepL API (στα Ιαπωνικά)

=back

=head1 AUTHOR

Kazumasa Utashiro

=head1 LICENSE

Copyright © 2023-2025 Kazumasa Utashiro.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
