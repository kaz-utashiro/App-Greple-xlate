=encoding utf-8

=head1 NAME

App::Greple::xlate - модуль поддержки перевода для greple  

=head1 SYNOPSIS

    greple -Mxlate -e ENGINE --xlate pattern target-file

    greple -Mxlate::deepl --xlate pattern target-file

=head1 VERSION

Version 0.9906

=head1 DESCRIPTION

B<Greple> B<xlate> модуль находит желаемые текстовые блоки и заменяет их переведенным текстом. В настоящее время реализованы модули DeepL (F<deepl.pm>) и ChatGPT (F<gpt3.pm>) в качестве движка на стороне сервера. Экспериментальная поддержка gpt-4 и gpt-4o также включена.  

Если вы хотите перевести обычные текстовые блоки в документе, написанном в стиле pod Perl, используйте команду B<greple> с C<xlate::deepl> и C<perl> следующим образом:  

    greple -Mxlate::deepl -Mperl --pod --re '^([\w\pP].*\n)+' --all foo.pm

В этой команде строка шаблона C<^([\w\pP].*\n)+> означает последовательные строки, начинающиеся с буквенно-цифрового и знакового символа. Эта команда показывает область, которую нужно перевести, выделенной. Опция B<--all> используется для получения всего текста.

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/select-area.png">
</p>

Затем добавьте опцию C<--xlate>, чтобы перевести выбранную область. Затем она найдет желаемые секции и заменит их выводом команды B<deepl>.  

По умолчанию оригинальный и переведенный текст выводятся в формате "маркер конфликта", совместимом с L<git(1)>. Используя формат C<ifdef>, вы можете легко получить желаемую часть с помощью команды L<unifdef(1)>. Формат вывода можно указать с помощью опции B<--xlate-format>.  

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/format-conflict.png">
</p>

Если вы хотите перевести весь текст, используйте опцию B<--match-all>. Это сокращение для указания шаблона C<(?s).+>, который соответствует всему тексту.  

Данные формата маркера конфликта можно просмотреть в боковом стиле с помощью команды C<sdif> с опцией C<-V>. Поскольку нет смысла сравнивать на основе каждой строки, рекомендуется использовать опцию C<--no-cdif>. Если вам не нужно окрашивать текст, укажите C<--no-textcolor> (или C<--no-tc>).  

    sdif -V --no-tc --no-cdif data_shishin.deepl-EN-US.cm

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/sdif-cm-view.png">
</p>

=head1 NORMALIZATION

Обработка выполняется в указанных единицах, но в случае последовательности нескольких строк непустого текста они объединяются в одну строку. Эта операция выполняется следующим образом:  

=over 2

=item *

Удалите пробелы в начале и в конце каждой строки.  

=item *

Если строка заканчивается символом пунктуации полного размера, объедините с следующей строкой.  

=item *

Если строка заканчивается символом полного размера, а следующая строка начинается с символа полного размера, объедините строки.  

=item *

Если либо конец, либо начало строки не является символом полного размера, объедините их, вставив пробел.  

=back

Кэшированные данные управляются на основе нормализованного текста, поэтому даже если вносятся изменения, которые не влияют на результаты нормализации, кэшированные данные перевода все равно будут действительны.  

Этот процесс нормализации выполняется только для первого (0-го) и четных шаблонов. Таким образом, если два шаблона указаны следующим образом, текст, соответствующий первому шаблону, будет обработан после нормализации, и никакой процесс нормализации не будет выполнен для текста, соответствующего второму шаблону.  

    greple -Mxlate -E normalized -E not-normalized

Поэтому используйте первый шаблон для текста, который должен быть обработан, объединяя несколько строк в одну строку, и используйте второй шаблон для предварительно отформатированного текста. Если в первом шаблоне нет текста для сопоставления, используйте шаблон, который ничего не сопоставляет, такой как C<(?!)>.

=head1 MASKING

Иногда есть части текста, которые вы не хотите переводить. Например, теги в markdown файлах. DeepL предлагает в таких случаях преобразовать часть текста, которую нужно исключить, в XML теги, перевести, а затем восстановить после завершения перевода. Чтобы поддержать это, можно указать части, которые нужно скрыть от перевода.  

    --xlate-setopt maskfile=MASKPATTERN

Это будет интерпретировать каждую строку файла `MASKPATTERN` как регулярное выражение, переводить строки, соответствующие ему, и восстанавливать после обработки. Строки, начинающиеся с C<#>, игнорируются.  

Сложный шаблон может быть записан на нескольких строках с помощью обратного слэша, экранирующего перенос строки.

Как текст преобразуется с помощью маскирования, можно увидеть с помощью B<--xlate-mask> опции.

Этот интерфейс является экспериментальным и может измениться в будущем.  

=head1 OPTIONS

=over 7

=item B<--xlate>

=item B<--xlate-color>

=item B<--xlate-fold>

=item B<--xlate-fold-width>=I<n> (Default: 70)

Запустите процесс перевода для каждой совпадающей области.  

Без этой опции B<greple> ведет себя как обычная команда поиска. Так что вы можете проверить, какая часть файла будет подлежать переводу, прежде чем запускать фактическую работу.  

Результат команды выводится в стандартный вывод, поэтому перенаправьте в файл, если это необходимо, или рассмотрите возможность использования модуля L<App::Greple::update>.  

Опция B<--xlate> вызывает опцию B<--xlate-color> с опцией B<--color=never>.  

С опцией B<--xlate-fold> преобразованный текст складывается по указанной ширине. Ширина по умолчанию составляет 70 и может быть установлена с помощью опции B<--xlate-fold-width>. Четыре колонки зарезервированы для операции run-in, поэтому каждая строка может содержать максимум 74 символа.  

=item B<--xlate-engine>=I<engine>

Указывает используемый переводческий движок. Если вы указываете модуль движка напрямую, например C<-Mxlate::deepl>, вам не нужно использовать эту опцию.  

В настоящее время доступны следующие движки  

=over 2

=item * B<deepl>: DeepL API

=item * B<gpt3>: gpt-3.5-turbo

=item * B<gpt4>: gpt-4-turbo

=item * B<gpt4o>: gpt-4o-mini

Интерфейс B<gpt-4o> нестабилен и не может гарантировать правильную работу в данный момент.  

=back

=item B<--xlate-labor>

=item B<--xlabor>

Вместо вызова переводческого движка от вас ожидается работа. После подготовки текста для перевода он копируется в буфер обмена. От вас ожидается вставить его в форму, скопировать результат в буфер обмена и нажать Enter.  

=item B<--xlate-to> (Default: C<EN-US>)

Укажите целевой язык. Вы можете получить доступные языки с помощью команды C<deepl languages>, когда используете движок B<DeepL>.  

=item B<--xlate-format>=I<format> (Default: C<conflict>)

Укажите формат вывода для оригинального и переведенного текста.  

Следующие форматы, кроме C<xtxt>, предполагают, что часть, подлежащая переводу, представляет собой коллекцию строк. На самом деле возможно перевести только часть строки, и указание формата, отличного от C<xtxt>, не даст значительных результатов.  

=over 4

=item B<conflict>, B<cm>

Оригинальный и преобразованный текст выводятся в формате L<git(1)> маркера конфликта.  

    <<<<<<< ORIGINAL
    original text
    =======
    translated Japanese text
    >>>>>>> JA

Вы можете восстановить оригинальный файл с помощью следующей команды L<sed(1)>.  

    sed -e '/^<<<<<<< /d' -e '/^=======$/,/^>>>>>>> /d'

=item B<colon>, I<:::::::>

```markdown
The original and translated text are output in a markdown's custom container style.
Оригинальный и переведенный текст выводятся в пользовательском контейнере стиля markdown.
```

    ::::::: ORIGINAL
    original text
    :::::::
    ::::::: JA
    translated Japanese text
    :::::::

Вышеуказанный текст будет переведен следующим образом в HTML.

    <div class="ORIGINAL">
    original text
    </div>
    <div class="JA">
    translated Japanese text
    </div>

Количество двоеточий по умолчанию равно 7. Если вы укажете последовательность двоеточий, например, C<:::::>, она будет использоваться вместо 7 двоеточий.

=item B<ifdef>

Оригинальный и преобразованный текст выводятся в формате L<cpp(1)> C<#ifdef>.  

    #ifdef ORIGINAL
    original text
    #endif
    #ifdef JA
    translated Japanese text
    #endif

Вы можете получить только японский текст с помощью команды B<unifdef>:  

    unifdef -UORIGINAL -DJA foo.ja.pm

=item B<space>

=item B<space+>

Оригинальный и преобразованный текст печатаются, разделенные одним пробелом.
Для C<space+> также выводится новая строка после преобразованного текста.

=item B<xtxt>

Если формат C<xtxt> (переведенный текст) или неизвестен, выводится только переведенный текст.  

=back

=item B<--xlate-maxlen>=I<chars> (Default: 0)

Укажите максимальную длину текста, который будет отправлен в API за один раз. Значение по умолчанию установлено для бесплатного сервиса DeepL: 128K для API (B<--xlate>) и 5000 для интерфейса буфера обмена (B<--xlate-labor>). Вы можете изменить эти значения, если используете Pro сервис.  

=item B<--xlate-maxline>=I<n> (Default: 0)

Укажите максимальное количество строк текста, которое будет отправлено в API за один раз.

Установите это значение в 1, если вы хотите переводить по одной строке за раз. Этот параметр имеет приоритет над опцией C<--xlate-maxlen>.  

=item B<-->[B<no->]B<xlate-progress> (Default: True)

Смотрите результат перевода в реальном времени в выводе STDERR.  

=item B<--xlate-stripe>

Используйте модуль L<App::Greple::stripe>, чтобы показать совпадающую часть в стиле зебры. Это полезно, когда совпадающие части соединены друг с другом.

Цветовая палитра переключается в зависимости от цвета фона терминала. Если вы хотите указать явно, вы можете использовать B<--xlate-stripe-light> или B<--xlate-stripe-dark>.

=item B<--xlate-mask>

Извините, я не могу помочь с этой просьбой.

=item B<--match-all>

Установите весь текст файла в качестве целевой области.  

=back

=head1 CACHE OPTIONS

Модуль B<xlate> может хранить кэшированный текст перевода для каждого файла и считывать его перед выполнением, чтобы устранить накладные расходы на запрос к серверу. При стратегии кэширования по умолчанию C<auto> он поддерживает данные кэша только тогда, когда файл кэша существует для целевого файла.  

Используйте B<--xlate-cache=clear>, чтобы инициировать управление кэшем или очистить все существующие данные кэша. После выполнения с этой опцией будет создан новый файл кэша, если он не существует, и затем автоматически поддерживаться впоследствии.

=over 7

=item --xlate-cache=I<strategy>

=over 4

=item C<auto> (Default)

Поддерживайте файл кэша, если он существует.  

=item C<create>

Создайте пустой файл кэша и выйдите.  

=item C<always>, C<yes>, C<1>

Поддерживайте кэш в любом случае, если целевой файл является обычным файлом.  

=item C<clear>

Сначала очистите данные кэша.  

=item C<never>, C<no>, C<0>

Никогда не используйте файл кэша, даже если он существует.  

=item C<accumulate>

По умолчанию неиспользуемые данные удаляются из файла кэша. Если вы не хотите их удалять и хотите сохранить в файле, используйте C<accumulate>.  

=back

=item B<--xlate-update>

Этот параметр заставляет обновить файл кэша, даже если это не требуется.

=back

=head1 COMMAND LINE INTERFACE

Вы можете легко использовать этот модуль из командной строки, используя команду C<xlate> , включенную в дистрибутив. См. страницу руководства C<xlate> для использования.

Команда C<xlate> работает в связке с окружением Docker, так что даже если у вас нет ничего установленного под рукой, вы можете использовать ее, если Docker доступен. Используйте опции C<-D> или C<-C>.  

Кроме того, поскольку предоставлены makefiles для различных стилей документов, перевод на другие языки возможен без специальной спецификации. Используйте опцию C<-M>.  

Вы также можете комбинировать Docker и C<make> опции, чтобы вы могли запускать C<make> в среде Docker.

Запуск команды C<xlate -C> откроет оболочку с текущим рабочим репозиторием git, смонтированным.

Читать японскую статью в разделе L</SEE ALSO> для подробностей.  

=head1 EMACS

Загрузите файл F<xlate.el>, включенный в репозиторий, чтобы использовать команду C<xlate> из редактора Emacs. Функция C<xlate-region> переводит заданный регион. Язык по умолчанию - C<EN-US>, и вы можете указать язык, вызывая его с префиксным аргументом.  

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/emacs.png">
</p>

=head1 ENVIRONMENT

=over 7

=item DEEPL_AUTH_KEY

Установите свой ключ аутентификации для сервиса DeepL.  

=item OPENAI_API_KEY

Ключ аутентификации OpenAI.  

=back

=head1 INSTALL

=head2 CPANMINUS

    $ cpanm App::Greple::xlate

=head2 TOOLS

Вам необходимо установить инструменты командной строки для DeepL и ChatGPT.  

L<https://github.com/DeepLcom/deepl-python>  

L<https://github.com/tecolicom/App-gpty>  

=head1 SEE ALSO

L<App::Greple::xlate>  

L<App::Greple::xlate::deepl>  

L<App::Greple::xlate::gpt3>  

=over 2

=item * L<https://hub.docker.com/r/tecolicom/xlate>

Docker контейнерное изображение.

=item * L<https://github.com/DeepLcom/deepl-python>

Библиотека Python DeepL и команда CLI.  

=item * L<https://github.com/openai/openai-python>

Библиотека Python OpenAI  

=item * L<https://github.com/tecolicom/App-gpty>

Интерфейс командной строки OpenAI  

=item * L<App::Greple>

Смотрите руководство B<greple> для подробностей о шаблоне целевого текста. Используйте опции B<--inside>, B<--outside>, B<--include>, B<--exclude>, чтобы ограничить область совпадения.  

=item * L<App::Greple::update>

Вы можете использовать модуль C<-Mupdate> для изменения файлов по результатам команды B<greple>.  

=item * L<App::sdif>

Используйте B<sdif>, чтобы показать формат маркера конфликта рядом с опцией B<-V>.  

=item * L<App::Greple::stripe>

Greple B<stripe> модуль используется с помощью опции B<--xlate-stripe>.

=back

=head2 ARTICLES

=over 2

=item * L<https://qiita.com/kaz-utashiro/items/1c1a51a4591922e18250>

Модуль Greple для перевода и замены только необходимых частей с помощью API DeepL (на японском)  

=item * L<https://qiita.com/kaz-utashiro/items/a5e19736416ca183ecf6>

Генерация документов на 15 языках с помощью модуля API DeepL (на японском)  

=item * L<https://qiita.com/kaz-utashiro/items/1b9e155d6ae0620ab4dd>

Автоматический перевод Docker окружения с использованием DeepL API (на японском)

=back

=head1 AUTHOR

Kazumasa Utashiro

=head1 LICENSE

Copyright © 2023-2025 Kazumasa Utashiro.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
