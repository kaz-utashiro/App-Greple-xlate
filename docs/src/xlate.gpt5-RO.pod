=encoding utf-8

=head1 NAME

App::Greple::xlate - modul de suport pentru traducere pentru greple

=head1 SYNOPSIS

    greple -Mxlate::deepl --xlate pattern target-file

    greple -Mxlate::gpt4 --xlate pattern target-file

    greple -Mxlate --xlate-engine gpt4 --xlate pattern target-file

=head1 VERSION

Version 0.9913

=head1 DESCRIPTION

B<Greple> B<xlate> modul găsește blocurile de text dorite și le înlocuiește cu textul tradus. În prezent, modulele DeepL (F<deepl.pm>) și ChatGPT 4.1 (F<gpt4.pm>) sunt implementate ca motor back-end.

Dacă doriți să traduceți blocuri de text normale într-un document scris în stilul pod al Perl, folosiți comanda B<greple> cu modulele C<xlate::deepl> și C<perl> astfel:

    greple -Mxlate::deepl -Mperl --pod --re '^([\w\pP].*\n)+' --all foo.pm

În această comandă, șirul de tipar C<^([\w\pP].*\n)+> înseamnă linii consecutive care încep cu litere și cifre și semne de punctuație. Această comandă arată zona ce urmează a fi tradusă evidențiată. Opțiunea B<--all> este folosită pentru a produce textul integral.

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/select-area.png">
</p>

Apoi adăugați opțiunea C<--xlate> pentru a traduce zona selectată. Atunci va găsi secțiunile dorite și le va înlocui cu ieșirea comenzii B<deepl>.

Implicit, textul original și cel tradus sunt tipărite în formatul „conflict marker” compatibil cu L<git(1)>. Folosind formatul C<ifdef>, puteți obține partea dorită cu comanda L<unifdef(1)> ușor. Formatul ieșirii poate fi specificat prin opțiunea B<--xlate-format>.

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/format-conflict.png">
</p>

Dacă doriți să traduceți întregul text, folosiți opțiunea B<--match-all>. Aceasta este o scurtătură pentru a specifica tiparul C<(?s).+> care se potrivește întregului text.

Datele în format conflict marker pot fi vizualizate în stil side-by-side cu comanda L<sdif|App::sdif> și opțiunea C<-V>. Deoarece nu are sens să comparați pe bază de șir, se recomandă opțiunea C<--no-cdif>. Dacă nu aveți nevoie să colorați textul, specificați C<--no-textcolor> (sau C<--no-tc>).

    sdif -V --no-filename --no-tc --no-cdif data_shishin.deepl-EN-US.cm

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/sdif-cm-view.png">
</p>

=head1 NORMALIZATION

Procesarea se face în unitățile specificate, dar în cazul unei secvențe de mai multe linii de text ne-gol, acestea sunt convertite împreună într-o singură linie. Această operație se efectuează după cum urmează:

=over 2

=item *

Eliminați spațiile albe de la începutul și sfârșitul fiecărei linii.

=item *

Dacă o linie se termină cu un caracter de punctuație full-width, concatenați cu linia următoare.

=item *

Dacă o linie se termină cu un caracter full-width și linia următoare începe cu un caracter full-width, concatenați liniile.

=item *

Dacă fie sfârșitul, fie începutul unei linii nu este un caracter full-width, concatenați-le inserând un caracter spațiu.

=back

Datele din cache sunt gestionate pe baza textului normalizat, astfel încât, chiar dacă se fac modificări care nu afectează rezultatele normalizării, datele de traducere din cache vor rămâne valabile.

Acest proces de normalizare se efectuează numai pentru modelul (tiparul) primul (al 0-lea) și pentru cele cu număr par. Astfel, dacă sunt specificate două tipare ca mai jos, textul care se potrivește primului tipar va fi procesat după normalizare, iar pe textul care se potrivește celui de-al doilea tipar nu se va efectua niciun proces de normalizare.

    greple -Mxlate -E normalized -E not-normalized

Prin urmare, folosiți primul tipar pentru textul care urmează să fie procesat prin combinarea mai multor linii într-o singură linie și folosiți al doilea tipar pentru text preformatat. Dacă nu există text care să se potrivească primului tipar, folosiți un tipar care nu se potrivește cu nimic, cum ar fi C<(?!)>.

=head1 MASKING

Ocazional, există părți din text pe care nu doriți să le traduceți. De exemplu, etichete în fișiere markdown. DeepL sugerează ca, în astfel de cazuri, partea de text care trebuie exclusă să fie convertită în etichete XML, tradusă, apoi restaurată după finalizarea traducerii. Pentru a susține acest lucru, este posibil să specificați părțile care vor fi mascate de la traducere.

    --xlate-setopt maskfile=MASKPATTERN

Aceasta va interpreta fiecare linie din fișierul `MASKPATTERN` ca o expresie regulată, va traduce șirurile care se potrivesc și va reveni după procesare. Liniile care încep cu C<#> sunt ignorate.

Un tipar complex poate fi scris pe mai multe linii cu newline scăpat prin backslash.

Modul în care textul este transformat prin mascarea poate fi văzut prin opțiunea B<--xlate-mask>.

Această interfață este experimentală și poate suferi modificări în viitor.

=head1 OPTIONS

=over 7

=item B<--xlate>

=item B<--xlate-color>

=item B<--xlate-fold>

=item B<--xlate-fold-width>=I<n> (Default: 70)

Pornește procesul de traducere pentru fiecare zonă potrivită.

Fără această opțiune, B<greple> se comportă ca o comandă de căutare normală. Astfel puteți verifica ce parte a fișierului va face obiectul traducerii înainte de a porni munca efectivă.

Rezultatul comenzii merge la ieșirea standard, deci redirecționați către fișier dacă este necesar sau luați în considerare folosirea modulului L<App::Greple::update>.

Opțiunea B<--xlate> apelează opțiunea B<--xlate-color> cu opțiunea B<--color=never>.

Cu opțiunea B<--xlate-fold>, textul convertit este împărțit la lățimea specificată. Lățimea implicită este 70 și poate fi setată prin opțiunea B<--xlate-fold-width>. Patru coloane sunt rezervate pentru operația run-in, astfel încât fiecare linie poate conține cel mult 74 de caractere.

=item B<--xlate-engine>=I<engine>

Specifică motorul de traducere care va fi folosit. Dacă specificați direct modulul motor, cum ar fi C<-Mxlate::deepl>, nu este necesar să folosiți această opțiune.

În acest moment, sunt disponibile următoarele motoare

=over 2

=item * B<deepl>: DeepL API

=item * B<gpt3>: gpt-3.5-turbo

=item * B<gpt4>: gpt-4.1

=item * B<gpt4o>: gpt-4o-mini

Interfața lui B<gpt-4o> este instabilă și nu poate fi garantat că va funcționa corect în acest moment.

=back

=item B<--xlate-labor>

=item B<--xlabor>

În loc să apelați motorul de traducere, se așteaptă să lucrați manual. După pregătirea textului de tradus, acesta este copiat în clipboard. Se așteaptă să îl lipiți în formular, să copiați rezultatul în clipboard și să apăsați Enter.

=item B<--xlate-to> (Default: C<EN-US>)

Specificați limba țintă. Puteți obține limbile disponibile cu comanda C<deepl languages> când folosiți motorul B<DeepL>.

=item B<--xlate-format>=I<format> (Default: C<conflict>)

Specificați formatul de ieșire pentru textul original și tradus.

Următoarele formate, altele decât C<xtxt>, presupun că partea de tradus este o colecție de linii. De fapt, este posibil să traduceți doar o porțiune a unei linii, dar specificarea unui format diferit de C<xtxt> nu va produce rezultate semnificative.

=over 4

=item B<conflict>, B<cm>

Textul original și cel convertit sunt tipărite în formatul marcatorilor de conflict L<git(1)>.

    <<<<<<< ORIGINAL
    original text
    =======
    translated Japanese text
    >>>>>>> JA

Puteți recupera fișierul original cu următoarea comandă L<sed(1)>.

    sed -e '/^<<<<<<< /d' -e '/^=======$/,/^>>>>>>> /d'

=item B<colon>, I<:::::::>

Textul original și cel tradus sunt afișate într-un stil de container personalizat pentru markdown.

    ::::::: ORIGINAL
    original text
    :::::::
    ::::::: JA
    translated Japanese text
    :::::::

Textul de mai sus va fi tradus în următorul format HTML.

    <div class="ORIGINAL">
    original text
    </div>
    <div class="JA">
    translated Japanese text
    </div>

Numărul de două puncte este 7 în mod implicit. Dacă specificați o secvență de două puncte precum C<:::::>, aceasta este folosită în locul celor 7 două puncte.

=item B<ifdef>

Textul original și cel convertit sunt tipărite în formatul L<cpp(1)> C<#ifdef>.

    #ifdef ORIGINAL
    original text
    #endif
    #ifdef JA
    translated Japanese text
    #endif

Puteți prelua doar textul japonez cu comanda B<unifdef>:

    unifdef -UORIGINAL -DJA foo.ja.pm

=item B<space>

=item B<space+>

Textul original și cel convertit sunt tipărite separate de o linie goală. Pentru C<space+>, se afișează și un rând nou după textul convertit.

=item B<xtxt>

Dacă formatul este C<xtxt> (text tradus) sau necunoscut, se tipărește doar textul tradus.

=back

=item B<--xlate-maxlen>=I<chars> (Default: 0)

Specificați lungimea maximă a textului care va fi trimis la API dintr-o singură dată. Valoarea implicită este setată pentru serviciul contului DeepL gratuit: 128K pentru API (B<--xlate>) și 5000 pentru interfața clipboard (B<--xlate-labor>). Este posibil să puteți schimba aceste valori dacă utilizați serviciul Pro.

=item B<--xlate-maxline>=I<n> (Default: 0)

Specificați numărul maxim de linii de text care vor fi trimise la API dintr-o singură dată.

Setați această valoare la 1 dacă doriți să traduceți câte o linie pe rând. Această opțiune are prioritate față de opțiunea C<--xlate-maxlen>.

=item B<--xlate-prompt>=I<text>

Specificați un prompt personalizat care să fie trimis motorului de traducere. Această opțiune este disponibilă doar atunci când folosiți motoarele ChatGPT (gpt3, gpt4, gpt4o). Puteți personaliza comportamentul traducerii oferind instrucțiuni specifice modelului AI. Dacă promptul conține C<%s>, acesta va fi înlocuit cu numele limbii țintă.

=item B<--xlate-context>=I<text>

Specificați informații contextuale suplimentare care să fie trimise motorului de traducere. Această opțiune poate fi utilizată de mai multe ori pentru a furniza multiple șiruri de context. Informațiile de context ajută motorul de traducere să înțeleagă fundalul și să producă traduceri mai precise.

=item B<--xlate-glossary>=I<glossary>

Specificați un ID de glosar care să fie utilizat pentru traducere. Această opțiune este disponibilă doar atunci când se folosește motorul DeepL. ID-ul glosarului trebuie obținut din contul dvs. DeepL și asigură traducerea consecventă a termenilor specifici.

=item B<-->[B<no->]B<xlate-progress> (Default: True)

Vedeți rezultatul traducerii în timp real în ieșirea STDERR.

=item B<--xlate-stripe>

Folosiți modulul L<App::Greple::stripe> pentru a afișa partea potrivită în stil zebra striping. Acest lucru este util atunci când părțile potrivite sunt conectate consecutiv.

Paleta de culori este comutată în funcție de culoarea fundalului terminalului. Dacă doriți să specificați explicit, puteți folosi B<--xlate-stripe-light> sau B<--xlate-stripe-dark>.

=item B<--xlate-mask>

Efectuați funcția de mascarea și afișați textul convertit așa cum este, fără restaurare.

=item B<--match-all>

Setați întregul text al fișierului ca zonă țintă.

=item B<--lineify-cm>

=item B<--lineify-colon>

În cazul formatelor C<cm> și C<colon>, ieșirea este împărțită și formatată linie cu linie. Prin urmare, dacă doar o porțiune dintr-o linie trebuie tradusă, nu se poate obține rezultatul așteptat. Aceste filtre repară ieșirea care este coruptă prin traducerea unei părți a unei linii într-o ieșire normală linie cu linie.

În implementarea curentă, dacă sunt traduse mai multe părți ale unei linii, acestea sunt afișate ca linii independente.

=back

=head1 CACHE OPTIONS

Modulul B<xlate> poate stoca textul de traducere în cache pentru fiecare fișier și îl poate citi înainte de execuție pentru a elimina costul interogării serverului. Cu strategia de cache implicită C<auto>, menține datele din cache numai atunci când fișierul de cache există pentru fișierul țintă.

Folosiți B<--xlate-cache=clear> pentru a iniția gestionarea cache-ului sau pentru a curăța toate datele de cache existente. Odată executată cu această opțiune, va fi creat un fișier de cache nou dacă nu există unul și apoi va fi menținut automat ulterior.

=over 7

=item --xlate-cache=I<strategy>

=over 4

=item C<auto> (Default)

Mențineți fișierul de cache dacă există.

=item C<create>

Creați fișier de cache gol și ieșiți.

=item C<always>, C<yes>, C<1>

Menține memoria cache oricum, atât timp cât ținta este un fișier normal.

=item C<clear>

Golește mai întâi datele din cache.

=item C<never>, C<no>, C<0>

Nu folosi niciodată fișierul cache chiar dacă există.

=item C<accumulate>

În mod implicit, datele neutilizate sunt eliminate din fișierul cache. Dacă nu dorești să le elimini și să le păstrezi în fișier, folosește C<accumulate>.

=back

=item B<--xlate-update>

Această opțiune forțează actualizarea fișierului cache chiar dacă nu este necesar.

=back

=head1 COMMAND LINE INTERFACE

Poți folosi ușor acest modul din linia de comandă folosind comanda C<xlate> inclusă în distribuție. Vezi pagina de manual C<xlate> pentru utilizare.

Comanda C<xlate> funcționează în concert cu mediul Docker, deci chiar dacă nu ai nimic instalat local, o poți folosi atâta timp cât Docker este disponibil. Folosește opțiunea C<-D> sau C<-C>.

De asemenea, deoarece sunt furnizate makefile-uri pentru diverse stiluri de documente, traducerea în alte limbi este posibilă fără specificații speciale. Folosește opțiunea C<-M>.

Poți combina și opțiunile Docker și C<make> astfel încât să poți rula C<make> într-un mediu Docker.

Rularea ca C<xlate -C> va lansa un shell cu depozitul git de lucru curent montat.

Citește articolul în japoneză din secțiunea L</SEE ALSO> pentru detalii.

=head1 EMACS

Încarcă fișierul F<xlate.el> inclus în depozit pentru a folosi comanda C<xlate> din editorul Emacs. Funcția C<xlate-region> traduce regiunea dată. Limba implicită este C<EN-US> și poți specifica limba apelând-o cu un argument prefix.

=for html <p>
<img width="750" src="https://raw.githubusercontent.com/kaz-utashiro/App-Greple-xlate/main/images/emacs.png">
</p>

=head1 ENVIRONMENT

=over 7

=item DEEPL_AUTH_KEY

Setează cheia ta de autentificare pentru serviciul DeepL.

=item OPENAI_API_KEY

Cheie de autentificare OpenAI.

=back

=head1 INSTALL

=head2 CPANMINUS

    $ cpanm App::Greple::xlate

=head2 TOOLS

Trebuie să instalezi instrumentele de linie de comandă pentru DeepL și ChatGPT.

L<https://github.com/DeepLcom/deepl-python>

L<https://github.com/tecolicom/App-gpty>

=head1 SEE ALSO

L<App::Greple::xlate>

L<App::Greple::xlate::deepl>

L<App::Greple::xlate::gpt4>

=over 2

=item * L<https://hub.docker.com/r/tecolicom/xlate>

Imagine de container Docker.

=item * L<https://github.com/DeepLcom/deepl-python>

Biblioteca Python DeepL și comanda CLI.

=item * L<https://github.com/openai/openai-python>

Biblioteca Python OpenAI

=item * L<https://github.com/tecolicom/App-gpty>

Interfața de linie de comandă OpenAI

=item * L<App::Greple>

Vezi manualul B<greple> pentru detalii despre modelul de text țintă. Folosește opțiunile B<--inside>, B<--outside>, B<--include>, B<--exclude> pentru a limita zona de potrivire.

=item * L<App::Greple::update>

Poți folosi modulul C<-Mupdate> pentru a modifica fișierele în funcție de rezultatul comenzii B<greple>.

=item * L<App::sdif>

Folosește B<sdif> pentru a afișa formatul marcatorilor de conflict alăturat cu opțiunea B<-V>.

=item * L<App::Greple::stripe>

Modulul Greple B<stripe> este folosit prin opțiunea B<--xlate-stripe>.

=back

=head2 ARTICLES

=over 2

=item * L<https://qiita.com/kaz-utashiro/items/1c1a51a4591922e18250>

Modul Greple pentru a traduce și înlocui doar părțile necesare cu API-ul DeepL (în japoneză)

=item * L<https://qiita.com/kaz-utashiro/items/a5e19736416ca183ecf6>

Generarea documentelor în 15 limbi cu modulul API DeepL (în japoneză)

=item * L<https://qiita.com/kaz-utashiro/items/1b9e155d6ae0620ab4dd>

Mediu Docker pentru traducere automată cu API-ul DeepL (în japoneză)

=back

=head1 AUTHOR

Kazumasa Utashiro

=head1 LICENSE

Copyright © 2023-2025 Kazumasa Utashiro.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
